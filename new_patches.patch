diff --git a/AirLib/include/sensors/SensorCollection.hpp b/AirLib/include/sensors/SensorCollection.hpp
index 9d3d257..339c01c 100644
--- a/AirLib/include/sensors/SensorCollection.hpp
+++ b/AirLib/include/sensors/SensorCollection.hpp
@@ -18,7 +18,8 @@ public: //types
         Barometer = 1,
         Imu = 2,
         Gps = 3,
-        Magnetometer = 4
+        Magnetometer = 4,
+        GroundTruth = 5,
     };
     typedef SensorBase* SensorBasePtr;
 public:
diff --git a/AirLib/include/vehicles/MultiRotorParams.hpp b/AirLib/include/vehicles/MultiRotorParams.hpp
index e9c2501..b12f8f7 100644
--- a/AirLib/include/vehicles/MultiRotorParams.hpp
+++ b/AirLib/include/vehicles/MultiRotorParams.hpp
@@ -14,6 +14,7 @@
 #include "sensors/imu/ImuSimple.hpp"
 #include "sensors/gps/GpsSimple.hpp"
 #include "sensors/magnetometer/MagnetometerSimple.hpp"
+#include "sensors/ground_truth/GroundTruthSensor.hpp"
 
 //below includes are because of setPhysicsGroundTruth methog
 #include "physics/Environment.hpp"
@@ -41,6 +42,7 @@ public: //types
         bool magnetometer = true;
         bool gps = true;
         bool barometer = true;
+        bool ground_truth = true;
     };
 
     struct Params {
@@ -226,6 +228,8 @@ protected: //static utility functions for derived classes to use
             sensors.insert(createSensor<GpsSimple>(sensor_storage), SensorCollection::SensorType::Gps);
         if (enabled_sensors.barometer)
             sensors.insert(createSensor<BarometerSimple>(sensor_storage), SensorCollection::SensorType::Barometer);
+        if (enabled_sensors.ground_truth)
+            sensors.insert(createSensor<GroundTruthSensor>(sensor_storage), SensorCollection::SensorType::GroundTruth);
     }
 
     template<typename SensorClass>
diff --git a/AirLib/src/controllers/MavLinkDroneController.cpp b/AirLib/src/controllers/MavLinkDroneController.cpp
index 0f17542..fad9c34 100644
--- a/AirLib/src/controllers/MavLinkDroneController.cpp
+++ b/AirLib/src/controllers/MavLinkDroneController.cpp
@@ -24,6 +24,7 @@
 #include "sensors/imu/ImuBase.hpp"
 #include "sensors/gps/GpsBase.hpp"
 #include "sensors/magnetometer/MagnetometerBase.hpp"
+#include "sensors/ground_truth/GroundTruthSensor.hpp"
 
 namespace msr { namespace airlib {
 
@@ -451,6 +452,42 @@ struct MavLinkDroneController::impl {
         }
         //else ignore message
     }
+    void sendHILState(const Quaternionr& orientation, const Vector3r& angular_velocity, const GeoPoint& geo_point, const Vector3r& velocity, float ind_airspeed, float true_airspeed, const Vector3r& acceleration) {
+        if (!is_simulation_mode_)
+            throw std::logic_error("Attempt to send simulated sensor messages while not in simulation mode");
+
+        mavlinkcom::MavLinkHilStateQuaternion hil_state;
+        hil_state.time_usec = static_cast<uint64_t>(Utils::getTimeSinceEpochNanos() / 1000.0);
+
+        hil_state.attitude_quaternion[0] = orientation.w();
+        hil_state.attitude_quaternion[1] = orientation.x();
+        hil_state.attitude_quaternion[2] = orientation.y();
+        hil_state.attitude_quaternion[3] = orientation.z();
+
+        hil_state.rollspeed = angular_velocity.x();
+        hil_state.pitchspeed = angular_velocity.y();
+        hil_state.yawspeed = angular_velocity.z();
+
+        hil_state.lat = static_cast<int32_t>(geo_point.latitude * 1E7);
+        hil_state.lon = static_cast<int32_t>(geo_point.longitude* 1E7);
+        hil_state.alt = static_cast<int32_t>(geo_point.altitude * 1000);
+
+        hil_state.vx = static_cast<int16_t>(velocity.x() * 100);
+        hil_state.vy = static_cast<int16_t>(velocity.y() * 100);
+        hil_state.vz = static_cast<int16_t>(velocity.z() * 100);
+
+        hil_state.ind_airspeed = static_cast<uint16_t>(ind_airspeed * 100);
+        hil_state.true_airspeed = static_cast<uint16_t>(true_airspeed * 100);
+
+        hil_state.xacc = static_cast<int16_t>(acceleration.x() * 1000);
+        hil_state.yacc = static_cast<int16_t>(acceleration.y() * 1000);
+        hil_state.zacc = static_cast<int16_t>(acceleration.z() * 1000);
+
+        if (hil_node_ != nullptr) {
+            hil_node_->sendMessage(hil_state);
+        }
+    }
+
 
     void sendHILSensor(const Vector3r& acceleration, const Vector3r& gyro, const Vector3r& mag, float abs_pressure, float pressure_alt)
     {
@@ -564,12 +601,19 @@ struct MavLinkDroneController::impl {
     {
         return static_cast<const GpsBase*>(sensors_->getByType(SensorCollection::SensorType::Gps));
     }
+    const GroundTruthSensor* getGroundTruth()
+    {
+        return static_cast<const GroundTruthSensor*>(sensors_->getByType(SensorCollection::SensorType::GroundTruth));
+    }
 
     void update()
     {
         if (sensors_ == nullptr || connection_ == nullptr || !connection_->isOpen())
             return;
 
+        const auto& gt_output = getGroundTruth()->getOutput();
+        sendHILState(gt_output.orientation, gt_output.angular_velocity, gt_output.position, gt_output.velocity, 0.0, 0.0, gt_output.acceleration);
+
         //send sensor updates
         const auto& imu_output = getImu()->getOutput();
         const auto& mag_output = getMagnetometer()->getOutput();
diff --git a/Unreal/Plugins/AirSim/Source/RecordingThread.cpp b/Unreal/Plugins/AirSim/Source/RecordingThread.cpp
index 8a95839..98ca83f 100644
--- a/Unreal/Plugins/AirSim/Source/RecordingThread.cpp
+++ b/Unreal/Plugins/AirSim/Source/RecordingThread.cpp
@@ -69,10 +69,10 @@ void FRecordingThread::SaveImage(TArray<uint8>& compressedPng)
 
             uint64_t timestamp_millis = static_cast<uint64_t>(clock_->nowNanos() / 1.0E6);
 
-            GameThread->record_file << timestamp_millis << "\t";
-            GameThread->record_file << kinematics.pose.position.x() << "\t" << kinematics.pose.position.y() << "\t" << kinematics.pose.position.z() << "\t";
-            GameThread->record_file << kinematics.pose.orientation.w() << "\t" << kinematics.pose.orientation.x() << "\t" << kinematics.pose.orientation.y() << "\t" << kinematics.pose.orientation.z() << "\t";
-            GameThread->record_file << "\n";
+            //GameThread->record_file << timestamp_millis << "\t";
+            //GameThread->record_file << kinematics.pose.position.x() << "\t" << kinematics.pose.position.y() << "\t" << kinematics.pose.position.z() << "\t";
+            //GameThread->record_file << kinematics.pose.orientation.w() << "\t" << kinematics.pose.orientation.x() << "\t" << kinematics.pose.orientation.y() << "\t" << kinematics.pose.orientation.z() << "\t";
+            //GameThread->record_file << "\n";
 
             UAirBlueprintLib::LogMessage(TEXT("Screenshot saved to:"), filePath, LogDebugLevel::Success);
             imagesSaved++;
@@ -109,4 +109,4 @@ void FRecordingThread::Shutdown()
         delete Runnable;
         Runnable = NULL;
     }
-}
\ No newline at end of file
+}
diff --git a/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.cpp b/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.cpp
index ea6a05d..81111ea 100644
--- a/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.cpp
+++ b/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.cpp
@@ -93,21 +93,21 @@ ECameraDirectorMode ASimModeBase::getInitialViewMode()
 
 void ASimModeBase::startRecording()
 {
-    if (record_file.is_open()) {
-        record_file.close();
-        UAirBlueprintLib::LogMessage(TEXT("Recording Error"), TEXT("File was already open"), LogDebugLevel::Failure);
-    }
+    //if (record_file.is_open()) {
+    //    record_file.close();
+    //    UAirBlueprintLib::LogMessage(TEXT("Recording Error"), TEXT("File was already open"), LogDebugLevel::Failure);
+    //}
 
-    std::string fullPath = common_utils::FileSystem::getLogFileNamePath(record_filename, "", ".txt", true);
-    common_utils::FileSystem::createTextFile(fullPath, record_file);
+    //std::string fullPath = common_utils::FileSystem::getLogFileNamePath(record_filename, "", ".txt", true);
+    //common_utils::FileSystem::createTextFile(fullPath, record_file);
 
-    if (record_file.is_open()) {
+    //if (record_file.is_open()) {
         is_recording = true;
 
-        UAirBlueprintLib::LogMessage(TEXT("Recording"), TEXT("Started"), LogDebugLevel::Success);
-    }
-    else
-        UAirBlueprintLib::LogMessage("Error creating log file", fullPath.c_str(), LogDebugLevel::Failure);
+    //    UAirBlueprintLib::LogMessage(TEXT("Recording"), TEXT("Started"), LogDebugLevel::Success);
+    //}
+    //else
+    //    UAirBlueprintLib::LogMessage("Error creating log file", fullPath.c_str(), LogDebugLevel::Failure);
 }
 
 bool ASimModeBase::toggleRecording()
@@ -123,11 +123,11 @@ bool ASimModeBase::toggleRecording()
 void ASimModeBase::stopRecording()
 {
     is_recording = false;
-    if (!record_file.is_open()) {
-        UAirBlueprintLib::LogMessage(TEXT("Recording Error"), TEXT("File was not open"), LogDebugLevel::Failure);
-    }
-    else
-        record_file.close();
+    //if (!record_file.is_open()) {
+    //    UAirBlueprintLib::LogMessage(TEXT("Recording Error"), TEXT("File was not open"), LogDebugLevel::Failure);
+    //}
+    //else
+    //    record_file.close();
     
     UAirBlueprintLib::LogMessage(TEXT("Recording"), TEXT("Stopped"), LogDebugLevel::Success);
-}
\ No newline at end of file
+}
diff --git a/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.h b/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.h
index 739d28b..3de7ed2 100644
--- a/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.h
+++ b/Unreal/Plugins/AirSim/Source/SimMode/SimModeBase.h
@@ -37,7 +37,7 @@ public:
 
     FString getRecordingPath();
 
-    std::ofstream record_file;
+    //std::ofstream record_file;
     std::string record_filename = "airsim_rec";    
 protected:
     virtual void setupInputBindings();
diff --git a/Unreal/Plugins/AirSim/Source/SimMode/SimModeWorldMultiRotor.cpp b/Unreal/Plugins/AirSim/Source/SimMode/SimModeWorldMultiRotor.cpp
index b9c557a..fd9862d 100644
--- a/Unreal/Plugins/AirSim/Source/SimMode/SimModeWorldMultiRotor.cpp
+++ b/Unreal/Plugins/AirSim/Source/SimMode/SimModeWorldMultiRotor.cpp
@@ -6,8 +6,29 @@
 #include <memory>
 #include "FlyingPawn.h"
 #include "Logging/MessageLog.h"
-#include "vehicles/MultiRotorParamsFactory.hpp"
+#include "vehicles/MultiRotorParamsFactory.hpp"
+#include "common/common_utils/Log.hpp"
 
+using namespace common_utils;
+
+class ASimLog : public Log
+{
+    FMessageLog log;
+
+public:
+    ASimLog() : log("BlueprintLog") {
+    }
+
+    virtual void logMessage(const char* message) override {
+        log.Info(FText::FromString(FString(message)));
+    }
+
+    virtual void logError(const char* message) override {
+        log.Error(FText::FromString(FString(message)));
+    }
+};
+
+static ASimLog GlobalASimLog;
 
 ASimModeWorldMultiRotor::ASimModeWorldMultiRotor()
 {
@@ -85,19 +106,46 @@ void ASimModeWorldMultiRotor::Tick(float DeltaSeconds)
 {
     if (fpv_vehicle_connector_ != nullptr && fpv_vehicle_connector_->isApiServerStarted() && getVehicleCount() > 0) {
 
-        if (isRecording() && record_file.is_open()) {
-            if (!isLoggingStarted)
-            {
-                FString imagePathPrefix = common_utils::FileSystem::getLogFileNamePath("img_", "", "", false).c_str();
-                FRecordingThread::ThreadInit(imagePathPrefix, this);
-                isLoggingStarted = true;
+        using namespace msr::airlib;
+        auto controller = static_cast<DroneControllerBase*>(fpv_vehicle_connector_->getController());
+        auto camera_type = controller->getImageTypeForCamera(0);
+        if (camera_type != DroneControllerBase::ImageType::None) { 
+            if (CameraDirector != nullptr) {
+                APIPCamera* camera = CameraDirector->getCamera(0);
+                EPIPCameraType pip_type;
+                if (camera != nullptr) {
+                    //TODO: merge these two different types?
+                    switch (camera_type) {
+                    case DroneControllerBase::ImageType::Scene:
+                        pip_type = EPIPCameraType::PIP_CAMERA_TYPE_SCENE; break;
+                    case DroneControllerBase::ImageType::Depth:
+                        pip_type = EPIPCameraType::PIP_CAMERA_TYPE_DEPTH; break;
+                    case DroneControllerBase::ImageType::Segmentation:
+                        pip_type = EPIPCameraType::PIP_CAMERA_TYPE_SEG; break;
+                    default:
+                        pip_type = EPIPCameraType::PIP_CAMERA_TYPE_NONE;
+                    }
+                    float width, height;
+                    image_.Empty();
+                    camera->getScreenshot(pip_type, image_, width, height);
+                    controller->setImageForCamera(0, camera_type, std::vector<uint8_t>(image_.GetData(), image_.GetData() + image_.Num()));
+                }
+            }
+        }
+
+        if (isRecording()/* && record_file.is_open()*/) {
+            if (!isLoggingStarted)
+            {
+                FString imagePathPrefix = common_utils::FileSystem::getLogFileNamePath("img_", "", "", false).c_str();
+                FRecordingThread::ThreadInit(imagePathPrefix, this);
+                isLoggingStarted = true;
             }
         }
 
-        if (!isRecording() && isLoggingStarted)
-        {
-            FRecordingThread::Shutdown();
-            isLoggingStarted = false;
+        if (!isRecording() && isLoggingStarted)
+        {
+            FRecordingThread::Shutdown();
+            isLoggingStarted = false;
         }
     }
 
@@ -110,10 +158,10 @@ void ASimModeWorldMultiRotor::EndPlay(const EEndPlayReason::Type EndPlayReason)
         fpv_vehicle_connector_->stopApiServer();
     }
 
-    if (isLoggingStarted)
-    {
-        FRecordingThread::Shutdown();
-        isLoggingStarted = false;
+    if (isLoggingStarted)
+    {
+        FRecordingThread::Shutdown();
+        isLoggingStarted = false;
     }
 
     for (AActor* actor : spawned_actors_) {
